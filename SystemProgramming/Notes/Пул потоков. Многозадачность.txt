Пул потоков. Многозадачность
Потоки (сами-по-себе) равноправные участники вычислитеольного процесса.
Пул потоков обеспечивает работу потоков в "подчиненном" режиме
 - потоки имеют низший (фоновый) приоритет (заметно только при нагруженноц системе)
 - потоки разрушаются при разрушении главного потока
 + пул регулирет кол-во одновременно работающих потоков, выравнивая нагрузку.

 Требование к потоковым методам - такое же, как и для обычных потоков
 Добавление на выполнение:
  ThreadPool - статический, создавать new ThreadPool не нужно
  ThreadPool.QueueUserWorkItem(Метод); - дополнительного .Start() не нужно,
  методж сразу планируется на выполнение
  ThreadPool.QueueUserWorkItem(PoolWorker, object); - передача object в параметры метода

  ------- Многозадачность -------
  Развитие идеи многопоточности привело к появлению задач (Task-C#, Promise-JS, Future-Java)
  Основные неудобства потоков:
   - нет возврата. приходиться использовать "общие ресурсы"
   - однотипность аргумента и невоможность нескольких аргументов

Запуск обычных методов
Task t1 = new Task(               | Полная схожесть с потоком, но вместо ссылки на метод
    () => TaskMethod0(20)         | можно передать Action / Lambda
);                                | 
t1.Start();                       | требуется отдельный запуск
                                   
Task t2 = Task.Run(               | Вариант с мгновеным запуском
    () => TaskMethod0(10)         | 
);                                | 
                                                           Между запуском первой задачи и ее 
                                                           окончанием можно выполнять другие действия
t1.Wait();                        | Ожидание окончания первой задачи |
                                  | Если t1 завершилась к этой строке, то игнорируется

Task.Run(() => TaskMethod0(30)); - эта инструкция выполниться после окончания t1

============== Задачи с возвратом ==============
                                  | Task<TResult> - перегрузка с возвратом TResult
Task<String> t =                  | Task<String> - ожидает возврат String
    Task.Run(                     | t - задача (Task), на методе с возвратом String
        () => TaskMethod1(40)     | Метод получает int, формирует и возвращает строку
);                                | 
Log2.Text = t.Result;             | t.Result - ожидание (Wait) плюс извлечение результата (строки)